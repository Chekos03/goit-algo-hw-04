_Порівняння алгоритмів сортування в Python_

У цьому проєкті порівнюються три алгоритми сортування:

- Insertion Sort
- Merge Sort
- Timsort (вбудований sorted / sort)
  Метою є емпірично підтвердити їхню ефективність та складність, використовуючи модуль timeit.

_Опис алгоритмів_

- Insertion Sort

  - Простий алгоритм зі складністю O(n²).
  - Добре працює лише на майже відсортованих масивах.

- Merge Sort

  - Рекурсивний алгоритм зі стабільною складністю O(n log n).
  - Не використовує “структуру” вхідних даних.

- Timsort
  - Гібрид Merge Sort і Insertion Sort, який використовує відсортовані ділянки (runs).
  - Складність — від O(n) до O(n log n).
  - Використовується Python у sorted() і .sort().

_Тестовані дані_

- Алгоритми протестовано на масивах: випадкових,відсортованих,обернено відсортованих
- Розміри масивів: 1000, 2000, 5000, 10000.

_Результати_
Випадкові дані

- Insertion Sort — найдовше (O(n^2))
- Merge Sort — швидко
- Timsort — найшвидше (у 10–20 разів швидше за merge)

Відсортовані дані

- Insertion Sort → дуже швидкий (O(n))
- Merge Sort → без оптимізацій
- Timsort → найшвидший

Обернені дані

- Insertion Sort → найгірший сценарій
- Merge Sort → стабільний
- Timsort → найкращий

_Висновки_

- Insertion Sort підходить тільки для малих або впорядкованих масивів.
- Merge Sort показує стабільну швидкість незалежно від даних.
- Timsort виявився найефективнішим на всіх наборах даних.

Саме тому Python використовує Timsort як основний алгоритм сортування.
